<!DOCTYPE html>
<html lang="en">
    <head>
        <!--
            This file was generated from 2009/nethack-term.md.
            Do not edit manually.
        -->
        <meta charset="utf-8" />
        <meta name="generator" content="pandoc" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />

                <meta name="date" content="2009-12-22" />
        
                <meta name="category" content="computing, unix" />
        
        <title>Nethack Zsh Prompt</title>

                <meta name="description" content="A Zsh multi-line prompt featuring the dog from Nethack.">
        
        
                <link rel="stylesheet" href="../base.css">
        
        
            </head>
    <body>
        <div class="documentwrapper">
        <p class="index">
            <a href="/">Home</a>
            | <a href="/years.html">Posts by Year</a>
            | <a href="/categories.html">Posts by Category</a>
        </p>
                <p class="date">2009-12-22</p>
        
        <h1 id="nethack-zsh-prompt">Nethack Zsh Prompt</h1>
        <p><strong>Easy multi-line prompts using Zsh arrays</strong></p>
        <h2 id="overview">Overview</h2>
        <p>This is a quick overview of my two- (sometimes three-) line Zsh prompt. It is built using Zsh arrays which makes the code extremely readable and mantainable. Each line of the prompt is an element in an array.</p>
        <p><a href="https://github.com/whiteinge/dotfiles/blob/master/.zsh_shouse_prompt">The code can be found on GitHub.</a></p>
        <p>In addition, I wanted the faithful dog from NetHack to wander around my prompt as I work. If you have ever played NetHack then you know how useful a good pet can be. Well, this helpfulness also extends to marathon coding sessions.</p>
        <figure>
        <img src="./nethack-term.png" alt="image" /><figcaption>image</figcaption>
        </figure>
        <p>Other than that the prompt should strive to be as minimalist as possible while still providing a wealth of information, as needed:</p>
        <ol type="1">
        <li>The prompt changes to red when the last command exited badly.</li>
        <li>The current working directory changes to yellow if it isn’t writable.</li>
        <li>The number of jobs show up, when there are any.</li>
        <li>The hostname only shows up when you’re SSH-ed into another system.</li>
        </ol>
        <h2 id="building-the-prompt">Building the prompt</h2>
        <p>A step by step walkthrough. Be sure to have the following Zsh manpages handy.</p>
        <dl>
        <dt>zshexpn(1)</dt>
        <dd><p>Look up expansions in the section titled “PARAMETER EXPANSION”. For example, <code>${(j: :)somearray}</code> to join the elements of an array into a string.</p>
        </dd>
        <dt>zshmisc(1)</dt>
        <dd><p>Look up escapes that you can use in your prompt in the section titled “SIMPLE PROMPT ESCAPES”.</p>
        </dd>
        <dt>zshparam(1)</dt>
        <dd><p>Read about arrays in Zsh in the section titled “ARRAY PARAMETERS”.</p>
        </dd>
        <dt>zshmodules(1)</dt>
        <dd><p>Read the syntax on how to use <code>zstyle</code>.</p>
        </dd>
        </dl>
        <h3 id="color-aliases">Color aliases</h3>
        <p>To keep things short lets make some aliases for the colors we intend to use. (This will also help later when we strip all the color out of the prompt to determine how wide it is.) As per the <a href="http://zshwiki.org/home/config/prompt">recommendation for prompts</a> on the Zsh wiki, we’re wrapping all our colors with <code>%{..%}</code>:</p>
        <pre><code>autoload -U colors &amp;&amp; colors
        local reset white gray green red
        
        reset=&quot;%{${reset_color}%}&quot;
        white=&quot;%{$fg[white]%}&quot;
        gray=&quot;%{$fg_bold[black]%}&quot;
        green=&quot;%{$fg_bold[green]%}&quot;
        red=&quot;%{$fg[red]%}&quot;
        yellow=&quot;%{$fg[yellow]%}&quot;</code></pre>
        <h3 id="the-top-line">The top line</h3>
        <p>We’re going to store the elements that make up the top line in an array for now. The top line is the most complicated line of our prompt and that will be useful when determining how much padding we need for the full-width padding:</p>
        <pre><code>local -a infoline</code></pre>
        <p>Add an element to the array containing a color escape based on if the current directory is writable:</p>
        <pre><code>[[ -w $PWD ]] &amp;&amp; infoline+=( ${green} ) || infoline+=( ${yellow} )</code></pre>
        <p>Add the escape to show the current directory &amp; path and reset the color:</p>
        <pre><code>infoline+=( &quot;%~ &quot; )
        infoline+=( &quot;${reset} &quot; )</code></pre>
        <p>Now add the current username:</p>
        <pre><code>infoline+=( &quot;%n&quot; )</code></pre>
        <p>If we’re ssh-ed into a machine, add the hostname:</p>
        <pre><code>[[ -n $SSH_CLIENT ]] &amp;&amp; infoline+=( &quot;@%m&quot; )</code></pre>
        <p>We want the top line to run the full width of the terminal so we need to take the width of the terminal window and subtract the width of all the characters we have assembled so far. Unfortunately this can be a little tricky because color escapes count as non-zero width.</p>
        <p>Since all our colors are already wrapped with <code>%{..%}</code> the easiest way to pull out the color is to do a simple search and replace for that wrapper. (The <code>(S)</code> tells it to search substrings.):</p>
        <pre><code>local i_width
        
        i_width=${(S)infoline//\%\{*\%\}}</code></pre>
        <p>Great, all the color is gone. We need to expand all the escapes so that <code>%~</code> gets expanded into <code>~/Pictures/lolcats/Superheroes</code> (for example) and <code>%n</code> gets expanded to <code>shouse</code>. While we’re at it, lets also count how many characters are in the string:</p>
        <pre><code>i_width=${#${(%)i_width}}</code></pre>
        <p>$COLUMNS is automatically set to the width of the terminal window; finally, we can find the difference of the two variables and see how much filler we’re going to need:</p>
        <pre><code>local i_filler
        
        i_filler=$(( $COLUMNS - $i_width ))</code></pre>
        <p>Then we can generate that filler; in this case we’re generating <code>.</code> characters with Zsh’s padding expansion:</p>
        <pre><code>local filler
        
        filler=&quot;${gray}${(l:${i_filler}::.:)}${reset}&quot;</code></pre>
        <p>Last we need to insert the filler into our array in the position we want. In this case we want it right in-between the <code>%~</code> and the <code>%n</code>:</p>
        <pre><code>infoline[2]=( &quot;${infoline[2]} ${filler} &quot; )</code></pre>
        <p>Our top line is complete.</p>
        <h3 id="the-remaining-lines">The remaining lines</h3>
        <p>The top line is the hard one since it’s full-width. We’re almost done. We still need the actual prompt line and we also want a third line to display version-control status when we’re in a Git/Mercurial/et al repository.</p>
        <p>Lets create a new array to hold each line in our prompt and add our top line as a string:</p>
        <pre><code>local -a lines
        
        lines+=( ${(j::)infoline} )</code></pre>
        <p>Zsh has an awesome contrib module for pulling information from VCS repositories called <code>vcs_info</code>. You can read about it in zshcontrib(1).</p>
        <p>See also: <a href="../2010/git-in-zsh.html">Git in Zsh</a></p>
        <p>See also: <a href="../2010/hg-in-zsh.rst">HG in Zsh</a></p>
        <p>When it detects that we are inside some VCS repository it fills the variable <code>$vcs_info_msg_0_</code> so lets add that variable to our array only if it contains information:</p>
        <pre><code>[[ -n ${vcs_info_msg_0_} ]] &amp;&amp; lines+=( &quot;${gray}${vcs_info_msg_0_}${reset}&quot; )</code></pre>
        <p>Now lets add the final line that contains the actual prompt:</p>
        <pre><code>lines+=( &quot;%(1j.${gray}%j${reset} .)%(0?.${white}.${red})%#${reset} &quot; )</code></pre>
        <p>Last, but not least, lets join all the array elements together in a string separating them with newlines:</p>
        <pre><code>PROMPT=${(F)lines}</code></pre>
        <p>That’s it! Pretty easy, huh?</p>
        <h2 id="conclusion">Conclusion</h2>
        <p>All together, the code looks like this:</p>
        <pre><code>function setprompt() {
            local -a lines infoline
            local x i pet dungeon filler i_width i_pad
        
            # A domestic animal, the _tame dog_ (_Canis familiaris_)
            pet=d
        
            ### First, assemble the top line
            # Current dir; show in yellow if not writable
            [[ -w $PWD ]] &amp;&amp; infoline+=( ${green} ) || infoline+=( ${yellow} )
            infoline+=( &quot;%~${reset} &quot; )
        
            # Username &amp; host
            infoline+=( &quot;%n&quot; )
            [[ -n $SSH_CLIENT ]] &amp;&amp; infoline+=( &quot;@%m&quot; )
        
            # Strip color to find text width &amp; make the full-width filler
            zstyle -T &quot;:pr-nethack:&quot; show-pet &amp;&amp; i_pad=4 || i_pad=0
        
            i_width=${(S)infoline//\%\{*\%\}} # search-and-replace color escapes
            i_width=${#${(%)i_width}} # expand all escapes and count the chars
        
            filler=&quot;${gray}${(l:$(( $COLUMNS - $i_width - $i_pad ))::.:)}${reset}&quot;
            infoline[2]=( &quot;${infoline[2]} ${filler} &quot; )
        
            ### Now, assemble all prompt lines
            lines+=( ${(j::)infoline} )
            [[ -n ${vcs_info_msg_0_} ]] &amp;&amp; lines+=( &quot;${gray}${vcs_info_msg_0_}${reset}&quot; )
            lines+=( &quot;%(1j.${gray}%j${reset} .)%(0?.${white}.${red})%#${reset} &quot; )
        
            ### Add dungeon floor to each line
            # Allow easy toggling of pet display
            if zstyle -T &quot;:pr-nethack:&quot; show-pet ; then
                dungeon=${(l:$(( ${#lines} * 3 ))::.:)}
                dungeon[$[${RANDOM}%${#dungeon}]+1]=$pet
        
                for (( i=1; i &lt; $(( ${#lines} + 1 )); i++ )) ; do
                    case $i in
                        1) x=1;; 2) x=4;; 3) x=7;; 4) x=10;;
                    esac
                    lines[$i]=&quot;${gray}${dungeon[x,$(( $x + 2 ))]} ${lines[$i]}${reset}&quot;
                done
            fi
        
            ### Finally, set the prompt
            PROMPT=${(F)lines}
        }
        
        function precmd {
            vcs_info
            setprompt
        }</code></pre>

                </div>
    </body>
</html>
